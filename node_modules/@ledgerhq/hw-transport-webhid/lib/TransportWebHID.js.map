{"version":3,"sources":["../src/TransportWebHID.js"],"names":["ledgerDevices","vendorId","ledgerUSBVendorId","isSupported","Promise","resolve","global","navigator","hid","getHID","TransportError","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","Transport","constructor","deviceModel","channel","Math","floor","random","packetSize","inputs","inputCallback","read","shift","success","onInputReport","e","buffer","Buffer","from","data","push","_disconnectEmitted","_emitDisconnect","emit","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","acc","getReducedResult","reduceResponse","catch","message","includes","DisconnectedDeviceDuringOperation","productId","addEventListener","request","open","openConnected","transport","onDisconnect","removeEventListener","DisconnectedDevice","close","exchangeBusyPromise","setScrambleKey","list","listen","observer","unsubscribed","then","error","TransportOpenUserCancelled","next","type","descriptor","complete","unsubscribe"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nconst isSupported = () =>\n  Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({ filters: ledgerDevices });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport<HIDDevice> {\n  device: HIDDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs = [];\n  inputCallback: ?(Buffer) => void;\n\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n\n  onInputReport = (e: InputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"],"file":"TransportWebHID.js"}